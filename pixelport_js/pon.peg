body
  = sep* n:node sep* { return n; }

node
  = number / string / boolean / object / array / nil / transform / dependency_reference / reference_pon / selector_pon

transform
  = function_name:identifier sep* arg:node sep* {
    return { _transform: function_name, arg: arg };
  }

dependency_reference
  = "@" selector:selector sep* "." sep* property_name:identifier {
    return { _type: 'dependency_reference', selector: selector, property_key: property_key };
  }

reference_pon
  = reference:reference { return { _type: 'reference', reference: reference } }

reference
  = "" selector:selector sep* "." sep* property_key:identifier {
    return { _type: 'named_prop_ref', selector: selector, property_key: property_key }
  }

selector_pon
  = "" selector:selector {
    return { _type: 'selector', selector: selector };
  }

selector_root
  = "this" sep* { return "this"; }
  / "root" sep* { return "root"; }
  / "parent" sep* { return "parent"; }
  / name:identifier sep* { return name; }
  / id:entity_id sep* { return id; }

selector_path
  = "/" sep* ematch:entity_match sep* { return "/" + ematch; }
  / ":!" sep* ematch:entity_match sep* { return ":!" + ematch; }
  / ":" sep* ematch:entity_match sep* { return ":" + ematch; }
  / "|parent|" sep* { return "|parent|"; }
  / "|prev-sibling|" sep* { return "|prev-sibling|"; }
  / "|next-sibling|" sep* { return "|next-sibling|"; }

selector
  = root:selector_root sep* path:(selector_path)* {
    return root + path;
  }

entity_match
  = sep* "*" sep* {
    return "*";
  }
  / sep* type_name:identifier sep* {
    return type_name;
  }
  / sep* "[" sep* a:entity_match sep* "&&" sep* b:entity_match sep* "]" sep* {
    return "[" + a + " && " + b + "]";
  }
  / sep* "[" sep* a:entity_match sep* "||" sep* b:entity_match sep* "]" sep* {
    return "[" + a + " || " + b + "]";
  }
  / sep* "[" sep* "name" sep* "=" sep* name:identifier sep* "]" sep* {
    return "[name=" + name + "]";
  }
  / sep* "[" sep* prop:identifier sep* "!=" sep* val:node sep* "]" sep* {
    return "[" + prop + "!=" + val + "]";
  }
  / sep* "[" sep* prop:identifier sep* "=" sep* val:node sep* "]" sep* {
    return "[" + prop + "=" + val + "]";
  }
  / sep* "[" sep* prop:identifier sep* "]" sep* {
    return "[" + prop + "]";
  }

array
  = "[" sep* nodes:array_items sep* "]" {
    return nodes;
  }

array_items
  = items:(sep* v:node sep* "," sep* { return v; })* sep* last:node? sep* ","? sep* {
  if (last) items.push(last);
  return items;
}

object
  = "{" sep* kvs:keyvals sep* "}" {
    let rv = {};
    kvs.forEach(entry => rv[entry.k] = entry.v);
    return rv;
  }

keyvals
  = items:(sep* k:keyval sep* "," sep* { return k; })* sep* last:keyval? sep* ","? sep* {
  if (last) items.push(last);
  return items;
}

keyval
  = sep* k:identifier sep* ":" sep* v:node sep* { return { k: k, v: v }; }

identifier
  = [a-zA-Z_][a-zA-Z_0-9]* { return text(); }

number
  = [-]?[0-9]+[.][0-9]+ { return parseFloat(text()); }
  / [-]?[0-9]+ { return parseFloat(text()); }

entity_id
  = "#" id:([0-9]+ { return text; }) { return id; }

nil
  = "(" sep* ")" { return { _type: 'nil' }; }

string
  = "'" s:char* "'" { return { _type: 'string', value: s } }

char
  = [^\\'] { return text().slice(1) }
  / [\\]. { return text()[1] }

boolean
  = "true" { return { _type: 'boolean', value: true } }
  / "false" { return { _type: 'boolean', value: false } }

comment = "//" [^\n]*
whitespace = [ \t\r\n]

sep
  = whitespace
  / comment
